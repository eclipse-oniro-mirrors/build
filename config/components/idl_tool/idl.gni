# Copyright (c) 2023-2024 Huawei Device Co., Ltd.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import("//build/ohos.gni")

if (ohos_indep_compiler_enable) {
  idl_root = "//binarys/foundation/ability/idl_tool/innerapis/idl/clang_x64"
} else {
  idl_root = "//foundation/ability/idl_tool"
}

idl_build_deps = ""
idl_out_root = ""

build_root = "//build"
toolchain_linux = "$build_root/toolchain/linux:clang_x64"
if (host_cpu == "arm64") {
  toolchain_mac = "$build_root/toolchain/mac:clang_arm64"
} else {
  toolchain_mac = "$build_root/toolchain/mac:clang_x64"
}
toolchain_win = "$build_root/toolchain/mingw:mingw_x86_64"

if (host_toolchain == toolchain_mac) {
  idl_out_root = get_label_info("$idl_root:idl($toolchain_mac)", "root_out_dir")
  idl_build_deps = [ "$idl_root:idl($toolchain_mac)" ]
} else if (host_toolchain == toolchain_win) {
  idl_out_root = get_label_info("$idl_root:idl($toolchain_win)", "root_out_dir")
  idl_build_deps = [ "$idl_root:idl($toolchain_win)" ]
} else {
  idl_out_root =
      get_label_info("$idl_root:idl($toolchain_linux)", "root_out_dir")
  idl_build_deps = [ "$idl_root:idl($toolchain_linux)" ]
}

if (ohos_indep_compiler_enable) {
  idl_build_path =
      idl_out_root +
      "/obj/binarys/foundation/ability/idl_tool/innerapis/idl/clang_x64/libs"
} else {
  idl_build_path = idl_out_root + "/ability/idl_tool"
}

template("idl_gen_interface") {
  not_needed(invoker, [ "dst_file" ])

  # idl sources
  src_idl_fullpath = []
  if (defined(invoker.sources)) {
    not_needed(invoker, [ "src_idl" ])

    # sources support multiple idl files
    src_idl_fullpath += invoker.sources
  } else {
    # src_idl support single idl file
    assert(defined(invoker.src_idl), "src_idl is required")
    src_idl_fullpath += [ invoker.src_idl ]
  }

  # language, default cpp, support c/cpp/rust
  language = "cpp"
  if (defined(invoker.language)) {
    assert(invoker.language == "c" || invoker.language == "cpp" ||
               invoker.language == "rust",
           "the language must be set to 'c' or 'cpp' or 'rust', default 'cpp'")
    language = invoker.language
  }

  # get build info
  build_info_args = [
    "-l",
    language,
    "-o",
    rebase_path(target_gen_dir),
    "-r",
    rebase_path("//"),
  ]
  foreach(idl_file, src_idl_fullpath) {
    build_info_args += [ "-f" ]
    build_info_args += [ rebase_path(idl_file) ]
  }
  build_info =
      exec_script("//build/config/components/idl_tool/build_sa_files_info.py",
                  build_info_args,
                  "json")
  assert(defined(build_info.include_dirs), "missing build_info.include_dirs")
  assert(defined(build_info.out_dir), "missing build_info.out_dir")
  assert(defined(build_info.sources), "missing build_info.sources")
  assert(defined(build_info.proxy_sources), "missing build_info.proxy_sources")
  assert(defined(build_info.stub_sources), "missing build_info.stub_sources")

  action("$target_name") {
    inputs = src_idl_fullpath
    deps = idl_build_deps
    script = "//build/config/components/idl_tool/idl.py"
    args = [
      "--src-idl",
      string_join(",", src_idl_fullpath),
      "--dst-path",
      rebase_path(target_gen_dir),
      "--idl-tool-path",
      rebase_path(idl_build_path),
      "--dst-file",
      string_join(",", rebase_path(build_info.sources)),
      "--language",
      language,
    ]
    if (defined(invoker.log_domainid)) {
      args += [
        "--log-domainid",
        invoker.log_domainid,
      ]
    }
    if (defined(invoker.log_tag)) {
      args += [
        "--log-tag",
        invoker.log_tag,
      ]
    }
    if (defined(invoker.hitrace)) {
      args += [
        "--hitrace",
        invoker.hitrace,
      ]
    }
    outputs = build_info.sources
  }

  # build so
  if ((language == "c" || language == "cpp") && defined(invoker.sources)) {
    idl_headers_config = target_name + "_idl_headers_config"
    config("$idl_headers_config") {
      include_dirs = [ target_gen_dir ]
      if (defined(invoker.sub_include)) {
        include_dirs += invoker.sub_include
      }
      include_dirs += build_info.include_dirs
    }

    lib_client = "lib" + target_name + "_proxy"
    lib_server = "lib" + target_name + "_stub"
    action_target_name = ":" + target_name

    # build client so
    ohos_shared_library(lib_client) {
      sources = []
      if (defined(invoker.sources_cpp)) {
        sources += invoker.sources_cpp
      }
      sources += build_info.proxy_sources
      if (defined(invoker.configs)) {
        configs = invoker.configs
      }
      public_configs = [ ":$idl_headers_config" ]
      deps = [ action_target_name ]
      if (is_standard_system) {
        public_deps = []
        if (defined(invoker.sequenceable_pub_deps)) {
          public_deps += invoker.sequenceable_pub_deps
        }
        external_deps = [ "c_utils:utils" ]
        if (defined(invoker.hitrace)) {
          external_deps += [ "hitrace:hitrace_meter" ]
        }
        if (defined(invoker.log_domainid)) {
          external_deps += [ "hilog:libhilog" ]
        }
        if (defined(invoker.sequenceable_ext_deps)) {
          external_deps += invoker.sequenceable_ext_deps
        }
        if (language == "c") {
          external_deps += [ "hdf_core:libhdf_ipc_adapter" ]
        } else if (language == "cpp") {
          external_deps += [ "ipc:ipc_single" ]
        }
      } else {
        external_deps = [ "hilog:libhilog" ]
      }
      if (defined(invoker.subsystem_name)) {
        subsystem_name = invoker.subsystem_name
      }
      if (defined(invoker.part_name)) {
        part_name = invoker.part_name
      }
      if (defined(invoker.innerapi_tags)) {
        innerapi_tags = invoker.innerapi_tags
      }
      if (defined(invoker.sanitize)) {
        sanitize = invoker.sanitize
      } else {
        sanitize = {
          cfi = true
          cfi_cross_dso = true
          debug = false
        }
      }
    }

    # build server so
    ohos_shared_library(lib_server) {
      sources = []
      if (defined(invoker.sources_cpp)) {
        sources += invoker.sources_cpp
      }
      sources += build_info.stub_sources
      if (defined(invoker.configs)) {
        configs = invoker.configs
      }
      public_configs = [ ":$idl_headers_config" ]
      deps = [ action_target_name ]
      if (is_standard_system) {
        public_deps = []
        if (defined(invoker.sequenceable_pub_deps)) {
          public_deps += invoker.sequenceable_pub_deps
        }
        external_deps = [ "c_utils:utils" ]
        if (defined(invoker.hitrace)) {
          external_deps += [ "hitrace:hitrace_meter" ]
        }
        if (defined(invoker.log_domainid)) {
          external_deps += [ "hilog:libhilog" ]
        }
        if (defined(invoker.sequenceable_ext_deps)) {
          external_deps += invoker.sequenceable_ext_deps
        }
        if (language == "c") {
          external_deps += [ "hdf_core:libhdf_ipc_adapter" ]
        } else if (language == "cpp") {
          external_deps += [ "ipc:ipc_single" ]
        }
      } else {
        external_deps = [ "hilog:libhilog" ]
      }
      if (defined(invoker.subsystem_name)) {
        subsystem_name = invoker.subsystem_name
      }
      if (defined(invoker.part_name)) {
        part_name = invoker.part_name
      }
      if (defined(invoker.sanitize)) {
        sanitize = invoker.sanitize
      } else {
        sanitize = {
          cfi = true
          cfi_cross_dso = true
          debug = false
        }
      }
    }

    # generate code and shared library
    group("$target_name" + "_idl_target") {
      deps = [
        ":$lib_client",
        ":$lib_server",
      ]
    }
  }
}
